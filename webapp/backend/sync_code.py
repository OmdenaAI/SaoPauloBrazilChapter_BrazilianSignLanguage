#!/usr/bin/env python3
"""
Script to sync required modules from /code to webapp/backend/shared_code
for standalone deployment.
"""

import shutil
import os
import sys
import re
from pathlib import Path
import argparse

def fix_imports_in_shared_code(target_dir: Path) -> int:
    """Fix imports in all Python files in shared_code directory to use shared_code prefix"""
    fixed_count = 0
    
    # Find all Python files
    python_files = list(target_dir.rglob("*.py"))
    
    for file_path in python_files:
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Track if we made changes
            original_content = content
            
            # Fix from model imports (both "from model." and "from model import")
            content = re.sub(r'from model(?=\.| import)', 'from shared_code.model', content)
            
            # Fix from preprocess imports (both "from preprocess." and "from preprocess import")
            content = re.sub(r'from preprocess(?=\.| import)', 'from shared_code.preprocess', content)
            
            # Fix from data imports (both "from data." and "from data import")
            content = re.sub(r'from data(?=\.| import)', 'from shared_code.data', content)
            
            # Only write if we made changes
            if content != original_content:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                print(f"  ‚úÖ Fixed imports in {file_path.relative_to(target_dir)}")
                fixed_count += 1
                
        except Exception as e:
            print(f"  ‚ùå Error fixing imports in {file_path}: {e}")
    
    return fixed_count

def sync_code_modules():
    """Sync required modules from /code to webapp/backend/shared_code"""
    
    # Get paths
    script_dir = Path(__file__).parent
    root_dir = script_dir.parent.parent  # Go up two levels to reach project root
    source_dir = root_dir / "code"
    target_dir = script_dir / "shared_code"  # Target is in same directory as script
    
    print(f"Syncing from {source_dir} to {target_dir}")
    
    # Remove existing target directory
    if target_dir.exists():
        print(f"Removing existing {target_dir}")
        shutil.rmtree(target_dir)
    
    # Create target directory
    target_dir.mkdir(parents=True, exist_ok=True)
    
    # Modules required based on imports in main.py and dependencies.py
    modules_to_copy = [
        # From main.py imports
        "data/download_videos.py",
        "preprocess/video_analyzer.py",
        "preprocess/preprocessor.py", 
        "preprocess/vizualisation.py",
        "preprocess/motion_detection.py",
        "preprocess/mediapipe_holistic.py",
        "model/features/",
        "model/utils/",
        "model/dataset/",
        "model/models/",
        
        # Additional dependencies that might be needed
        "preprocess/__init__.py",
        "data/__init__.py",
        "model/__init__.py",
        "model/features/__init__.py",
        "model/utils/__init__.py",
        "model/dataset/__init__.py",
    ]
    
    copied_count = 0
    for module in modules_to_copy:
        source = source_dir / module
        target = target_dir / module
        
        if not source.exists():
            print(f"‚ö†Ô∏è  Warning: Source module {module} not found at {source}")
            continue
            
        try:
            if source.is_file():
                # Copy single file
                target.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy2(source, target)
                print(f"‚úÖ Copied file: {module}")
                copied_count += 1
                
            elif source.is_dir():
                # Copy entire directory
                shutil.copytree(source, target, dirs_exist_ok=True)
                print(f"‚úÖ Copied directory: {module}")
                copied_count += 1
                
        except Exception as e:
            print(f"‚ùå Error copying {module}: {e}")
    
    # Create __init__.py files for Python packages
    init_files = [
        target_dir / "__init__.py",
        target_dir / "data" / "__init__.py",
        target_dir / "preprocess" / "__init__.py", 
        target_dir / "model" / "__init__.py",
    ]
    
    for init_file in init_files:
        if not init_file.exists():
            init_file.parent.mkdir(parents=True, exist_ok=True)
            init_file.write_text("# Auto-generated by sync script\n")
            print(f"‚úÖ Created: {init_file.relative_to(target_dir)}")
    
    print(f"\nüéâ Sync complete! Copied {copied_count} modules.")
    print(f"Target directory: {target_dir}")
    
    # Fix imports in copied files
    print("\nüîß Fixing imports in copied files...")
    fixed_count = fix_imports_in_shared_code(target_dir)
    print(f"‚úÖ Fixed imports in {fixed_count} files")
    
    # Show what was copied
    print("\nüìÅ Copied structure:")
    for item in sorted(target_dir.rglob("*")):
        if item.is_file():
            rel_path = item.relative_to(target_dir)
            print(f"  üìÑ {rel_path}")
        elif item.is_dir():
            rel_path = item.relative_to(target_dir)
            print(f"  üìÅ {rel_path}/")

def main():
    parser = argparse.ArgumentParser(description="Sync code modules for standalone deployment")
    parser.add_argument("--dry-run", action="store_true",
                       help="Show what would be copied without actually copying")
    
    args = parser.parse_args()
    
    if args.dry_run:
        print("üîç Dry run mode - showing what would be copied:")
        # Just show the modules that would be copied
        source_dir = Path(__file__).parent.parent.parent / "code"
        modules = [
            "data/download_videos.py",
            "preprocess/video_analyzer.py", 
            "preprocess/preprocessor.py",
            "preprocess/vizualisation.py",
            "model/features/",
            "model/utils/",
            "model/dataset/",
        ]
        
        for module in modules:
            source = source_dir / module
            if source.exists():
                print(f"  ‚úÖ Would copy: {module}")
            else:
                print(f"  ‚ùå Missing: {module}")
        return
    
    # Sync the modules
    sync_code_modules()
    
    print("\n‚úÖ Sync complete! Modules copied to webapp/backend/shared_code/")
    print("üí° Imports have been automatically fixed to use shared_code prefix.")

if __name__ == "__main__":
    main() 